# sns-service-db-design

## 1. 프로젝트 구조 (Repository Structure)
* **sns-service-db-design/** : SNS 데이터베이스 설계 프로젝트 루트
    * **database/**
        * **schema/**
            * `create_tables.sql` : 테이블 생성 및 제약 조건 정의 스크립트
        * **seed/**
            * `sample_data.sql` : 테스트 및 시나리오 검증용 데이터 스크립트
    * **docs/**
        * `sns_erd_v2.0.png` : 최종  ERD 이미지 파일
    * `README.md` : 프로젝트 상세 명세 및 업데이트 기록 (본 파일)

![최종 ERD](docs/sns_erd_v2.0.png)

### 2. 기획 의도 (Why)
- 기존 게시글 중심의 단순 설계를 넘어 사용자 간의 유기적인 상호작용(팔로우, 차단, 대댓글)과 실시간 통신 기반의 채팅 기능을 포함한 현대적 SNS 데이터 구조를 구축하고자 했습니다.
- 특히 AI Agent와 RAG 기술을 적용할 때 데이터 간의 관계를 명확히 파악하여 정보를 추출할 수 있도록 표준화된 설계를 목표로 했습니다.

### 3. 설계 및 구조 (Architecture)
- **팔로우 시스템**: `follow` 테이블을 통해 사용자 간의 다대다(N:M) 관계를 자기 참조 구조로 설계했습니다.
- **알림 및 해시태그**: 사용자의 활동(좋아요, 댓글 등)을 실시간으로 감지할 수 있는 알림 테이블과 콘텐츠 분류를 위한 해시태그 연결 테이블을 구성했습니다.
- **채팅 시스템 정규화**: chatroom, chatparticipant, chatmessage로 구조를 분리하여 1:1 채팅부터 그룹 채팅까지 유연하게 확장 가능한 다대다 관계를 구현했습니다.
- **실무 표준 명명 규칙**: username 대신 nickname을 사용하여 서비스 성격을 반영했으며, receiver_id 및 sender_id와 같은 직관적인 명칭을 사용하여 데이터 주체를 명확히 했습니다.

### 4. 핵심 로직 및 기술 선택 이유 (Core Logic & Selection)
- **데이터 정합성 유지**: 모든 외래키(FK)에 엄격한 제약 조건을 설정하고, 게시글 이미지(feedimage), 좋아요(feedlike), 북마크(feedbookmark) 등을 독립 테이블로 구성하여 관리 효율을 높였습니다.
- **확장성 있는 타입 설정**: 공개 여부나 그룹 여부 등은 TINYINT(1)을 사용하여 불리언 필드로 활용했고, 비밀번호는 암호화 저장을 위해 VARCHAR(255)로 넉넉하게 할당했습니다.

### 5. 트러블슈팅 (Troubleshooting)
- **에러**: 차단(blocks) 테이블 설계 시 users_id 단일 컬럼만 사용하여 차단 관계의 주체와 대상을 구분할 수 없는 논리적 오류 발생.
- **원인**: 하나의 컬럼으로는 '차단한 사람'과 '차단당한 사람'의 관계를 동시에 표현하거나 조회할 수 없음을 확인했습니다.
- **해결**: blocker_id와 blocked_id로 컬럼을 나누고 각각 users 테이블의 id를 참조하는 셀프 조인 구조로 변경하여 해결했습니다.

### 6. 업데이트 기록 (Changelog)
- v1.0 : 사용자 및 게시글 기본 CRUD 설계
- v1.1 : 팔로우 및 해시태그 기능 추가
- v1.2 : 단체 채팅 확장 구조 및 통합 알림 시스템 설계 완료 
- v2.0 : 저장소 폴더 구조 표준화(schema/seed 분리), 차단 및 대댓글 셀프 조인 로직 반영, 통합 알림 및 채팅 시스템 고도화 

### 7. 실무 관점의 참견 (Insight)
- 실제 서비스라면 알림 데이터가 폭증할 수 있습니다. 이때는 모든 알림을 RDB에 저장하기보다 Redis 같은 빠른 저장소를 쓰거나, 오래된 알림은 주기적으로 백업(Archiving)하는 전략이 필요합니다. 또한, 채팅 메시지의 경우 읽음 처리(is_read) 상태를 어떻게 실시간으로 업데이트할지도 인덱스 설계 시 중요하게 고려해야 합니다.
- 대댓글의 경우 서비스 규모가 커지면 재귀 쿼리의 성능 문제가 발생할 수 있으므로, 조회 빈도에 따라 CTE 최적화나 별도의 정렬 순서 컬럼 관리가 필요할 수 있습니다. 또한 차단 관계가 모든 콘텐츠 조회 시 필터링 조건으로 붙기 때문에 blocks 테이블에 대한 효율적인 인덱스 설계가 매우 중요합니다.

### 8. 성장 포인트 (Retrospective)
- `chatparticipant`와 같은 중간 테이블의 필요성을 배우며 다대다 관계를 실무에서 어떻게 푸는지 깨달았습니다. 또한 `snake_case`를 활용한 일관된 변수명 설정이 협업에서 얼마나 중요한지 알게 되었습니다.
- 폴더 구조를 체계적으로 관리하는 것이 협업의 기초임을 배웠습니다. 특히 단순한 기능 구현을 넘어 셀프 조인과 다대다 관계 해소 등 복잡한 데이터 관계를 실무 수준으로 풀어내는 경험을 쌓았습니다.