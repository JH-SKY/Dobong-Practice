# SNS 서비스 데이터베이스 설계 고도화 프로젝트

## 1. 📂 프로젝트 구조 (Repository Structure)
* **database/**
    * **sns-service-practice/** : SNS DB 설계 프로젝트
        * `sns_erd_v1.0.drawio` : 초기 게시글 중심 설계
        * `sns_final_erd.png` : 최종 고도화 ERD 이미지
        * `README.md` : 프로젝트 상세 명세서 (본 파일)

![최종 고도화 ERD](sns_final_erd.png)

### 2. 기획 의도 (Why)
- 단순한 게시글 작성을 넘어 사용자 간의 상호작용(팔로우, 채팅, 알림)이 활발한 현대적인 SNS의 데이터 구조를 이해하고 설계하기 위함입니다.
- 대규모 사용자 환경에서도 데이터가 꼬이지 않고 확장 가능하도록 테이블 간의 관계를 설정하는 것을 목표로 했습니다.

### 3. 설계 및 구조 (Architecture)
- **팔로우 시스템**: `follow` 테이블을 통해 사용자 간의 다대다(N:M) 관계를 자기 참조 구조로 설계했습니다.
- **채팅 시스템**: 1:1 채팅뿐만 아니라 향후 단체 채팅으로의 확장을 고려하여 `chatroom`과 `chatparticipant`를 분리한 구조를 도입했습니다.
- **알림 및 해시태그**: 사용자의 활동(좋아요, 댓글 등)을 실시간으로 감지할 수 있는 알림 테이블과 콘텐츠 분류를 위한 해시태그 연결 테이블을 구성했습니다.

### 4. 핵심 로직 및 기술 선택 이유 (Core Logic & Selection)
- **중간 테이블(Mapping Table) 활용**: 사용자(`user`)와 채팅방(`chatroom`) 사이에 참여자(`chatparticipant`) 테이블을 두어, 다대다 관계를 효율적으로 관리했습니다.
- **데이터 타입 최적화**: 실무 환경을 고려하여 고유 식별자에는 정수형 PK를 사용하고, 확장성을 위해 `is_group`, `is_private` 같은 불리언(Boolean) 필드를 적재적소에 배치했습니다.

### 5. 트러블슈팅 (Troubleshooting)
- **문제**: 팔로우 기능 설계 시 누가 누구를 팔로우하는지 방향성이 헷갈리는 문제 발생.
- **원인**: 단일 사용자 테이블 내에서 관계를 정의하다 보니 주체와 대상을 구분하는 컬럼명이 모호했음.
- **해결**: `follower_id`(팔로우를 하는 사람)와 `following_id`(팔로우를 받는 사람)로 명확히 네이밍하여 논리적 오류를 해결했습니다.

### 6. 업데이트 기록 (Changelog)
- v1.0 : 사용자 및 게시글 기본 CRUD 설계
- v1.1 : 팔로우 및 해시태그 기능 추가
- v1.2 : 단체 채팅 확장 구조 및 통합 알림 시스템 설계 완료 (최종)

### 7. 실무 관점의 참견 (Insight)
- 실제 서비스라면 알림 데이터가 폭증할 수 있습니다. 이때는 모든 알림을 RDB에 저장하기보다 Redis 같은 빠른 저장소를 쓰거나, 오래된 알림은 주기적으로 백업(Archiving)하는 전략이 필요합니다. 또한, 채팅 메시지의 경우 읽음 처리(is_read) 상태를 어떻게 실시간으로 업데이트할지도 인덱스 설계 시 중요하게 고려해야 합니다.

### 8. 성장 포인트 (Retrospective)
- `chatparticipant`와 같은 중간 테이블의 필요성을 배우며 다대다 관계를 실무에서 어떻게 푸는지 깨달았습니다. 또한 `snake_case`를 활용한 일관된 변수명 설정이 협업에서 얼마나 중요한지 알게 되었습니다.