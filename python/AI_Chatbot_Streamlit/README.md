# 메모리 기반 AI 비서 챗봇 (AI Secretary with Memory)

### 1. 기획 의도 (Why)
- OpenAI API를 활용하여 단순 일회성 답변이 아닌, 이전 대화의 맥락을 기억하고 유지하는 챗봇 시스템을 구축함.
- 터미널 기반의 봇과 웹 UI 기반(Streamlit)의 봇을 각각 구현하며 인터페이스에 따른 데이터 관리 방식을 익힘.

### 2. 설계 및 구조 (Architecture)
- **API 연동**: `gpt-4o-mini` 모델을 사용하여 비용 효율적인 대화 엔진 구축.
- **메모리 시스템**: Python 리스트(History)에 대화 내용을 누적하여 API 전송 시 전체 문맥을 전달하는 구조.
- **웹 인터페이스**: `Streamlit`의 `session_state`를 활용하여 새로고침 시에도 대화 내용이 휘발되지 않도록 관리.

### 3. 핵심 로직 및 기술 선택 이유 (Core Logic & Selection)
- **문맥 유지(Context Persistence)**: 사용자의 질문과 AI의 답변을 순차적으로 `messages` 리스트에 저장하여 대화의 흐름을 유지함.
- **Streamlit Session State**: 웹 환경의 특성(코드 재실행)을 극복하고 사용자의 대화 데이터를 유지하기 위해 세션 상태 관리 기술을 적용함.
- **Streaming UX**: 사용자 경험(UX) 향상을 위해 답변이 생성되는 대로 화면에 출력되는 스트리밍 방식을 채택함.

### 4. 트러블슈팅 (Troubleshooting)
- **문제**: Streamlit에서 대화 입력 시마다 화면이 초기화되어 이전 답변이 사라지는 현상 발생.
- **원인**: Streamlit은 상태 변화 시 전체 코드를 다시 실행하기 때문에 일반 변수는 초기화됨.
- **해결**: `st.session_state`를 사용하여 대화 리스트를 브라우저 세션에 저장함으로써 데이터 유실을 방지함.

### 5. 업데이트 기록 (Changelog)
- v1.0 : 터미널 기반 CLI 챗봇 구현 (기본 메모리 기능).
- v1.1 : Streamlit 기반 웹 UI 챗봇 구현 및 스트리밍 효과 적용.
- v1.2 : `.env` 파일을 활용한 API KEY 보안 관리 적용.

### 6. 실무 관점의 참견 (Insight)
- 현재는 전체 대화 기록을 전송하지만, 대화가 길어지면 토큰 비용이 급증하고 모델의 기억 용량을 초과할 수 있음.
- 실무에서는 **'최근 5개 대화만 유지'**하거나 **'대화 요약본(Summary)'**을 함께 전달하는 전략(Sliding Window)이 필요함.

### 7. 성장 포인트 (Retrospective)
- API를 단순 호출하는 것을 넘어, '상태(State)'를 관리하는 것이 실제 서비스 개발에서 얼마나 중요한지 깨달음.
- `.gitignore`를 통해 `.env` 같은 보안 민감 파일을 관리하는 법을 익혀 안전한 개발 습관을 형성함.